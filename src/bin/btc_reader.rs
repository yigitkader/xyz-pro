//! Standalone BTC Address Reader & Matcher
//!
//! Reads .raw files generated by btc_keygen and matches against targets.json
//!
//! Usage: btc_reader [OPTIONS]
//!
//! Options:
//!   --targets FILE     Path to targets.json (default: targets.json)
//!   --input DIR        Directory with .raw files (default: ./output)
//!   --output FILE      Output file for matches (default: matches.json)
//!   --watch            Watch mode: continuously scan for new files
//!   --interval SECS    Watch interval in seconds (default: 5)
//!   --threads N        Number of threads (default: auto)

use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use clap::{Parser, ValueEnum};

use xyz_pro::reader::{TargetSet, RawFileScanner, save_matches, ReaderConfig};
use xyz_pro::cli::{CommonArgs, format_number};

#[derive(Parser, Debug)]
#[command(name = "btc_reader", about = "BTC Address Reader & Matcher", long_about = None)]
struct Args {
    /// Path to targets.json file
    #[arg(short = 'T', long = "targets", default_value = "targets.json")]
    targets: String,
    
    /// Directory with .raw files
    #[arg(short = 'i', long = "input", default_value = "./output")]
    input: String,
    
    /// Output file for matches
    #[arg(short = 'o', long = "output", default_value = "matches.json")]
    output: String,
    
    /// Watch mode: continuously scan for new files
    #[arg(short = 'w', long = "watch")]
    watch: bool,
    
    /// Watch interval in seconds
    #[arg(short = 's', long = "interval", default_value_t = 5)]
    interval: u64,
    
    /// Number of threads (default: auto-detect)
    #[arg(short = 't', long = "threads")]
    threads: Option<usize>,
    
    /// Print help information
    #[arg(short = 'h', long = "help")]
    help: bool,
}

fn main() {
    let args = Args::parse();
    
    let mut config = ReaderConfig::default();
    config.targets_path = args.targets;
    config.input_dir = args.input;
    config.output_path = args.output;
    if let Some(threads) = args.threads {
        config.threads = threads;
    }
    
    let watch_mode = args.watch;
    let interval = args.interval;
    
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘           ğŸ” BTC Address Reader v1.0                       â•‘");
    println!("â•‘                                                            â•‘");
    println!("â•‘   Reads generated keys and matches against targets         â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();
    
    // Load targets
    println!("ğŸ“‚ Loading targets from: {}", config.targets_path);
    let targets = match TargetSet::load(&config.targets_path) {
        Ok(t) => t,
        Err(e) => {
            eprintln!("âŒ Failed to load targets: {}", e);
            std::process::exit(1);
        }
    };
    println!();
    
    // Create scanner
    let scanner = RawFileScanner::new(targets, config.threads);
    
    // Setup Ctrl+C handler
    // IMPORTANT: Do NOT call exit(0) directly - this can cause data loss if
    // matches are being saved to disk. Instead, set the running flag to false
    // and let the main loop exit gracefully.
    let running = Arc::new(AtomicBool::new(true));
    let running_clone = running.clone();
    
    ctrlc::set_handler(move || {
        println!("\n\nâš ï¸  Received Ctrl+C, stopping gracefully...");
        running_clone.store(false, Ordering::SeqCst);
        // DO NOT call exit(0) here - let the main loop finish any pending I/O
    }).expect("Error setting Ctrl+C handler");
    
    if watch_mode {
        // Watch mode - continuously scan for new files
        println!("ğŸ‘€ Watch mode enabled (interval: {}s)", interval);
        println!("   Input directory: {}", config.input_dir);
        println!();
        
        // Pass running flag to watch loop for graceful shutdown
        if let Err(e) = scanner.watch_and_scan_with_flag(&config.input_dir, interval, running.clone()) {
            if !running.load(Ordering::SeqCst) {
                // Ctrl+C was pressed - not an error
                println!("ğŸ‘‹ Watch mode stopped by user");
            } else {
                eprintln!("âŒ Watch error: {}", e);
                std::process::exit(1);
            }
        }
    } else {
        // Single scan mode - with graceful shutdown support
        println!("ğŸ” Scanning directory: {}", config.input_dir);
        println!();
        
        // Pass running flag for graceful Ctrl+C handling
        match scanner.scan_directory_with_flag(&config.input_dir, Some(running.clone())) {
            Ok(result) => {
                // Save results even on partial scan (Ctrl+C)
                print_results(&result, &config.output_path);
            }
            Err(e) => {
                if !running.load(Ordering::SeqCst) {
                    // Ctrl+C was pressed - not an error
                    println!("ğŸ‘‹ Scan stopped by user");
                } else {
                    eprintln!("âŒ Scan error: {}", e);
                    std::process::exit(1);
                }
            }
        }
    }
    
    println!("âœ… Reader exited cleanly");
}

fn print_results(result: &xyz_pro::reader::ScanResult, output_path: &str) {
    println!();
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘                    ğŸ“Š Scan Results                         â•‘");
    println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    println!("â•‘  Files scanned:       {:>35} â•‘", result.files_scanned);
    println!("â•‘  Keys scanned:        {:>35} â•‘", format_number(result.keys_scanned));
    println!("â•‘  Time elapsed:        {:>32.2} sec â•‘", result.elapsed_secs);
    println!("â•‘  Keys per second:     {:>32.2} M â•‘", result.keys_per_second() / 1_000_000.0);
    println!("â•‘  Matches found:       {:>35} â•‘", result.matches.len());
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    if !result.matches.is_empty() {
        println!();
        println!("ğŸ¯ MATCHES FOUND:");
        for m in &result.matches {
            println!("   {} = {}", m.address, m.private_key);
            println!("      Type: {}, File: {}, Offset: {}", m.address_type, m.file, m.offset);
        }
        
        // Save to file
        if let Err(e) = save_matches(&result.matches, output_path) {
            eprintln!("âŒ Failed to save matches: {}", e);
        } else {
            println!();
            println!("ğŸ’¾ Matches saved to: {}", output_path);
        }
    }
}




