//! Standalone BTC Address Reader & Matcher
//!
//! Reads .raw files generated by btc_keygen and matches against targets.json
//!
//! Usage: btc_reader [OPTIONS]
//!
//! Options:
//!   --targets FILE     Path to targets.json (default: targets.json)
//!   --input DIR        Directory with .raw files (default: ./output)
//!   --output FILE      Output file for matches (default: matches.json)
//!   --watch            Watch mode: continuously scan for new files
//!   --interval SECS    Watch interval in seconds (default: 5)
//!   --threads N        Number of threads (default: auto)

use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};

use xyz_pro::reader::{TargetSet, RawFileScanner, save_matches, ReaderConfig};

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let config = parse_args(&args);
    let watch_mode = args.iter().any(|a| a == "--watch" || a == "-w");
    let interval = parse_interval(&args);
    
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘           ðŸ” BTC Address Reader v1.0                       â•‘");
    println!("â•‘                                                            â•‘");
    println!("â•‘   Reads generated keys and matches against targets         â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();
    
    // Load targets
    println!("ðŸ“‚ Loading targets from: {}", config.targets_path);
    let targets = match TargetSet::load(&config.targets_path) {
        Ok(t) => t,
        Err(e) => {
            eprintln!("âŒ Failed to load targets: {}", e);
            std::process::exit(1);
        }
    };
    println!();
    
    // Create scanner
    let scanner = RawFileScanner::new(targets, config.threads);
    
    // Setup Ctrl+C handler
    // IMPORTANT: Do NOT call exit(0) directly - this can cause data loss if
    // matches are being saved to disk. Instead, set the running flag to false
    // and let the main loop exit gracefully.
    let running = Arc::new(AtomicBool::new(true));
    let running_clone = running.clone();
    
    ctrlc::set_handler(move || {
        println!("\n\nâš ï¸  Received Ctrl+C, stopping gracefully...");
        running_clone.store(false, Ordering::SeqCst);
        // DO NOT call exit(0) here - let the main loop finish any pending I/O
    }).expect("Error setting Ctrl+C handler");
    
    if watch_mode {
        // Watch mode - continuously scan for new files
        println!("ðŸ‘€ Watch mode enabled (interval: {}s)", interval);
        println!("   Input directory: {}", config.input_dir);
        println!();
        
        // Pass running flag to watch loop for graceful shutdown
        if let Err(e) = scanner.watch_and_scan_with_flag(&config.input_dir, interval, running.clone()) {
            if !running.load(Ordering::SeqCst) {
                // Ctrl+C was pressed - not an error
                println!("ðŸ‘‹ Watch mode stopped by user");
            } else {
                eprintln!("âŒ Watch error: {}", e);
                std::process::exit(1);
            }
        }
    } else {
        // Single scan mode
        println!("ðŸ” Scanning directory: {}", config.input_dir);
        println!();
        
        match scanner.scan_directory(&config.input_dir) {
            Ok(result) => {
                print_results(&result, &config.output_path);
            }
            Err(e) => {
                eprintln!("âŒ Scan error: {}", e);
                std::process::exit(1);
            }
        }
    }
    
    println!("âœ… Reader exited cleanly");
}

fn print_results(result: &xyz_pro::reader::ScanResult, output_path: &str) {
    println!();
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘                    ðŸ“Š Scan Results                         â•‘");
    println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    println!("â•‘  Files scanned:       {:>35} â•‘", result.files_scanned);
    println!("â•‘  Keys scanned:        {:>35} â•‘", format_number(result.keys_scanned));
    println!("â•‘  Time elapsed:        {:>32.2} sec â•‘", result.elapsed_secs);
    println!("â•‘  Keys per second:     {:>32.2} M â•‘", result.keys_per_second() / 1_000_000.0);
    println!("â•‘  Matches found:       {:>35} â•‘", result.matches.len());
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    if !result.matches.is_empty() {
        println!();
        println!("ðŸŽ¯ MATCHES FOUND:");
        for m in &result.matches {
            println!("   {} = {}", m.address, m.private_key);
            println!("      Type: {}, File: {}, Offset: {}", m.address_type, m.file, m.offset);
        }
        
        // Save to file
        if let Err(e) = save_matches(&result.matches, output_path) {
            eprintln!("âŒ Failed to save matches: {}", e);
        } else {
            println!();
            println!("ðŸ’¾ Matches saved to: {}", output_path);
        }
    }
}

fn parse_args(args: &[String]) -> ReaderConfig {
    let mut config = ReaderConfig::default();
    
    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {
            "--targets" | "-t" => {
                if i + 1 < args.len() {
                    config.targets_path = args[i + 1].clone();
                    i += 1;
                } else {
                    eprintln!("âŒ --targets requires a file path");
                    std::process::exit(1);
                }
            }
            "--input" | "-i" => {
                if i + 1 < args.len() {
                    config.input_dir = args[i + 1].clone();
                    i += 1;
                } else {
                    eprintln!("âŒ --input requires a directory path");
                    std::process::exit(1);
                }
            }
            "--output" | "-o" => {
                if i + 1 < args.len() {
                    config.output_path = args[i + 1].clone();
                    i += 1;
                } else {
                    eprintln!("âŒ --output requires a file path");
                    std::process::exit(1);
                }
            }
            "--threads" | "-n" => {
                if i + 1 < args.len() {
                    match args[i + 1].parse::<usize>() {
                        Ok(n) if n > 0 => config.threads = n,
                        Ok(_) => {
                            eprintln!("âŒ --threads must be greater than 0");
                            std::process::exit(1);
                        }
                        Err(e) => {
                            eprintln!("âŒ Invalid thread count '{}': {}", args[i + 1], e);
                            std::process::exit(1);
                        }
                    }
                    i += 1;
                } else {
                    eprintln!("âŒ --threads requires a number");
                    std::process::exit(1);
                }
            }
            "--help" | "-h" => {
                print_help();
                std::process::exit(0);
            }
            _ => {}
        }
        i += 1;
    }
    
    config
}

/// Parse interval argument with explicit error handling
fn parse_interval(args: &[String]) -> u64 {
    for i in 0..args.len().saturating_sub(1) {
        if args[i] == "--interval" || args[i] == "-s" {
            let val = &args[i + 1];
            match val.parse::<u64>() {
                Ok(n) if n > 0 => return n,
                Ok(_) => {
                    eprintln!("âŒ Invalid interval: must be > 0");
                    std::process::exit(1);
                }
                Err(e) => {
                    eprintln!("âŒ Invalid interval value '{}': {}", val, e);
                    std::process::exit(1);
                }
            }
        }
    }
    5 // Default 5 seconds
}

fn print_help() {
    println!("BTC Address Reader & Matcher");
    println!();
    println!("USAGE:");
    println!("    btc_reader [OPTIONS]");
    println!();
    println!("OPTIONS:");
    println!("    -t, --targets FILE     Path to targets.json (default: targets.json)");
    println!("    -i, --input DIR        Directory with .raw files (default: ./output)");
    println!("    -o, --output FILE      Output file for matches (default: matches.json)");
    println!("    -w, --watch            Watch mode: continuously scan for new files");
    println!("    -s, --interval SECS    Watch interval in seconds (default: 5)");
    println!("    -n, --threads N        Number of threads (default: auto)");
    println!("    -h, --help             Print this help message");
    println!();
    println!("EXAMPLES:");
    println!("    btc_reader --targets targets.json --input ./keys");
    println!("    btc_reader --watch --input ./keys --interval 10");
    println!();
    println!("FILE FORMAT:");
    println!("    Reads .raw files generated by btc_keygen --format raw");
    println!("    Header: [magic:4][version:1][reserved:3][count:8] = 16 bytes");
    println!("    Entry:  [privkey:32][pubkey_hash:20][p2sh_hash:20] = 72 bytes");
    println!();
    println!("ADDRESS MATCHING:");
    println!("    pubkey_hash = hash160(compressed_pubkey)");
    println!("      â†’ P2PKH  (1...)   : base58check(0x00 + pubkey_hash)");
    println!("      â†’ P2WPKH (bc1q...): bech32(version=0, pubkey_hash)");
    println!("    p2sh_hash = hash160(0x0014 + pubkey_hash)");
    println!("      â†’ P2SH   (3...)   : base58check(0x05 + p2sh_hash)");
}

fn format_number(n: u64) -> String {
    let s = n.to_string();
    let mut result = String::new();
    let chars: Vec<char> = s.chars().collect();
    
    for (i, c) in chars.iter().enumerate() {
        if i > 0 && (chars.len() - i) % 3 == 0 {
            result.push(',');
        }
        result.push(*c);
    }
    
    result
}

